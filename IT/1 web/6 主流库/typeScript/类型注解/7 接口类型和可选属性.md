## 什么是接口类型

- 和number,string,boolean,enum这些数据类型一样,接口也是一种类型, 也是用来约束使用者的
- 在限制类的时候 语法关键 `implements` 在[方式6](#方式6)中有示例
- 其他时候关键字 `interface` 开头

## 定义一个接口类型

- 规定了 object 类型中的属性是怎样的

## 方式1

- 属性的个数和值必须一致

```typescript
/*
定义一个接口类型接口定义的 key名称 ,值类型, 和参数个数必须一样
*/ 
interface FullName{
    firstName:string
    lastName:string
}
// 虚拟值
let obj = {
    firstName:'Jonathan',
    lastName:'Lee'
};
// 使用接口类型约束
function say({firstName, lastName}:FullName):void {
    console.log(`我的姓名是:${firstName}_${lastName}`);
}
say(obj);
```

## 方式2

- 有些属性和值必须要有且明确
- 有些属性可有可无
- 少一个或少多个,就把可能少的值添加 ? 变为可选属性

````ts
interface FullName{
  firstName:string	// 必填属性写法
  lastName?:string  // 添加一个?号,这标识为可选属性,不是必填属性
}
````

## 方式3

- 某个属性只能读,不能赋值

````ts
interface Person {
  readonly name: string;  // 这个是能读不能赋值,因为接受属性初始化也不能赋值.所以永远是 undefined
   name2: string;
  age?: number;
}

````

## 情况1

```ts
// 
interface person{
  name:string	
}

const getPersonName = (person: Person): void => {
  console.log(person.name);
};

const person2 = {
  name: 'dell',
  sex: 'male',
};
// 同样多个一个属性
getPersonName(person);  // 不会报错
getPersonName({name:'dell',sex:'male'});  // 字面量的方式就会报错, 字面量会出发严格监测模式
```



## 方式4

- 对于属性个数不限制

```ts
interface FullName{
  firstName:string
  lastName?:string
  [propName:string]:any //此处的意思 key 是字符串类型,值任意类型.
}
// 这样下面的值多几个都不会报错
say({firstName:'Jonathan', lastName:'Lee', middleName:"666", abc:'abc', 123:123, def:"def"});


```

## 可选属性和索引签名

- 企业开发中参数有时会多一个或少一个. 需要用可选属性和索引签名

```typescript
/*
多一个或多多个值的方法
*/
// 方式一: 使用类型断言(类型断言的意思就是让编译器不要干涉判断,我知道什么情况)
say({firstName:'Jonathan', lastName:'Lee', middleName:"666", abc:'abc'} as FullName);
// 方式二: 抽取参数为变量
let obj = {firstName:'Jonathan', lastName:'Lee', middleName:"666", abc:'abc'};
say(obj);
// 方式三: 使用索引签名, 接口处添加索引签名
interface FullName{
    firstName:string
    lastName?:string
    [propName:string]:any //此处的意思 key 是字符串类型,值任意类型.
}
// 这样下面的值多几个都不会报错
say({firstName:'Jonathan', lastName:'Lee', middleName:"666", abc:'abc', 123:123, def:"def"});


```





## 方式5 

- 添加方法

````ts
interface Person {
   name: string;
  age?: number;
  [propName: string]: any;
  say(): string;
}

const person = {
  name: 'dell',
  sex: 'male',
  say() {
    return 'say hello';
  }
};

getPersonName(person);
````



## 方式6

- 给类添加接口类型限制

```ts
interface Person {
   name: string;
  age?: number;
  [propName: string]: any;
  say(): string;
}
//  实现了必须有的 name 和 say 就不会报错了
class User implements Person {
  name = 'dell';
  say() {
    return 'hello';
  }
}

```



## 方式7 接口继承

```ts
interface Person {
   name: string;
  say(): string;
}

interface Teacher extends Person {
  teach(): string;
}
const getPersonName = (person: Person): void => {
  console.log(person.name);
};

// 必须实现 teacher 接口和 person 接口的属性和方法
const person = {
  name: 'dell',
  say() {
    return 'say hello';
  },
  teach() {
    return 'teach';
  }
};

getPersonName(person);
```



## 方式8 接口函数

```ts
// 定义函数的类型, 必须接受一个 string 的参数,且返回值是 string
interface SayHi {
  (word: string): string;
}

// 这个函数的类型叫 sayHi
const say: SayHi = (word: string) => {
  return word;
};

```

