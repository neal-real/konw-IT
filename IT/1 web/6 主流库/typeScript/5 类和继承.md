## class 类 

-  private, protected, public 访问类型
  - public 允许我在类的内外被调用(不写默认就是这个)
  - private 允许在类内被使用
  - protected 允许在类内及继承的子类中使用
    - 在继承的类中,可以使用

- 定义类

```ts
class Person {
  public name: string;
  public sayHi() {
    this.name;
    console.log('hi');
  }
  private sayABC() {
    this.name;
  }
}

// 使用类
const person = new Person();	// 创建类对象
person.name = 'dell';					// 赋值类属性
console.log(person.name);			// 调用类属性
person.sayHi(); 							// 调用类方法

```



## 继承类

-  子类可以直接调用父类方法和属性
- super 关键字 等于 父类
- 子类的方法和父类一致,会覆盖父类, 但是可以通过 super 调用父类的重名方法

```ts
class Person {
  name = 'dell';
  // this 就是 Person
  public getName() {
   return this.name;
  }
}
class Teacher extends Person {
  // this 就是 teacher
  getTeacherName() { 
    super.getName()
    return 'teacher'
  }
}

const teacher = new Teacher()
console.log(teacher.name);
console.log(teacher.getName());
console.log(teacher.getTeacherName());

```

## 

## 继承-构造器

- `constructor` 是一个自动执行的构造器函数

- 子类重写 `constructor` 构造器函数时,必须调用`spuer()` 函数, 如果父类没有写构造器,可以不用传参

- 因为使用了 ts ,所以必须根据父类构造器传入指定参数. 否则报错

- 写法说明

  - ```ts
    class Person {
      // 传统写法
      public name: string;
      constructor(name: string) {
        this.name = name;
      }
      // 简化写法: 这样一行等于上面4行的写法
      constructor(public name: string) {}
    }
    ```

- 

```ts
class Person {
  constructor(public name: string) { }
}

class Teacher extends Person {
  constructor(public age: number) {
    super('dell');
  }
}

const teacher = new Teacher(28);
console.log(teacher.age);
console.log(teacher.name);
```



