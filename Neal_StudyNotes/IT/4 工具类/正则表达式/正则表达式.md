# 正则表达式

> ​	Regular Expression，简写为regex、regexp或RE

语法:  /规则(模式)/修饰符

~~~js
实例:  
var patt = /www/i
实例解析：
/www是一个模式 (用于检索)。
i  是一个修饰符 (搜索不区分大小写)。
~~~

## 修饰符

| 修饰符 | 描述                                     |
| :----- | :--------------------------------------- |
| i      | 无视大小写,且匹配到第一个条件,停止匹配   |
| g      | 全局匹配完成对所有**匹配项**,对应的操作. |
| m      | 执行多行匹配。                           |



## 规则(模式)

#### 位置标识符

 

| 表达式 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| $      | 表示行尾, 例1: png$ 表示行尾必须是png . 例2: abc$  表示结尾必须是abc |
| ^      | 表示开头, 例1: ^# 表示必须是#开头.   在[ ] 表示取反          |



##### 基础规则

| 表达式      | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| /abc/       | 完全匹配: 就是匹配有没有**字符串**abc                        |
| **\|**      | **规则: 或**                                                 |
| /abc\|tbc/  | 匹配内容中有字符串abc返回ture,有tbc也返回ture                |
| (a\|b\|c)tt | 匹配内容中att 或btt或ctt 都满足条件                          |
| **[ ]**     | **规则: 字符集** 里面包含的字符都是用                        |
| /[abcd]/    | [ ] 字符集的意思;                                            |
| /[0-9]/     | 0 至 9 的数字。                                              |
| /[a-z]/     | 小写 a 到小写 z 的字符的26个字符。                           |
| /[A-Z]/     | 大写 A 到大写 Z 的字符的26个字符。                           |
| /[A-z]/     | 大写 A 到小写 z 的字符的52个字符。                           |
| **^** 取反  | 在字符集 [ ] 中使用^ 意思: 不取和字符集匹配的内容, 取不匹配的内容 |


##### 基础规则分组

~~~js
/( )/ 分组 (red\|blue\|green)这段字符串中red或blue或green都匹配
不过分组也分很多类型。
"(pattern)" 小括号单纯的包含了子表达式，表示此分组可以被捕获。捕获的意思就是此分组的内容会被保存下来，后续可以从匹配的集合中获取到。
"(?:pattern)" 小括号中增加了 ?: 前缀，表示此分组不可以被捕获。后续匹配的集合中就不会包含此分组信息。
这样说下来，不太好理解。这里需要结合具体开发语言的实现来说。先留个悬念，后面会讲到。
"(?=pattern)" 小括号中增加了 ?= 前缀，表示的是匹配此分组，但是此分组里的内容不需要被获取。
"(?!pattern)" 小括号中增加了 ?! 前缀，表示的是匹配此分组之外的内容，但是此分组里的内容不需要被获取。
举个栗子：
正则表达式 "Windows(?=95|98|NT|2000)" 可以匹配字符串 "Windows2000" 中的 "Windows"，但是不能匹配 "Windows3.1" 中的 Windowds。
正则表达式 "Windows(?!95|98|NT|2000)" 可以匹配字符串 "Windows3.1" 中的 "Windows"，但是不能匹配 "Windows2000" 中的 Windowds。



~~~



#####  元字符是拥有特殊含义的字符：

| 元字符 | 描述                                         |
| :----- | :------------------------------------------- |
| .      | 查找单个字符，除了换行和行结束符。           |
| \w     | 查找单词字符。                               |
| \W     | 查找非单词字符。                             |
| \d     | 查找数字。等价于 "[0-9]"                     |
| \D     | 查找非数字字符。等价于 [**^**0-9]            |
| \s     | 查找空白字符。等价于 "[\f\n\r\t\v]"          |
| \S     | 查找非空白字符。等价于 "[**^**\f\n\r\t\v]"。 |
| \b     | 匹配单词边界。                               |
| \B     | 匹配非单词边界。                             |
| \0     | 查找 NUL 字符。                              |
| \n     | 查找换行符。                                 |
| \f     | 查找换页符。                                 |
| \r     | 查找回车符。                                 |
| \t     | 查找制表符。                                 |
| \v     | 查找垂直制表符。                             |
| \xxx   | 查找以八进制数 xxx 规定的字符。              |
| \xdd   | 查找以十六进制数 dd 规定的字符。             |
| \uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符。  |


##### 量词:



| 量词     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| fo*f     | f和f之间有任意零个或多个o                                    |
| fo+f     | f和f之间至少有一个o                                          |
| fo?f     | f和f之间至少有一个o或零个0                                   |
| fo{2}f   | f和f之间只能有2个o                                           |
| fo{2,}f  | f和f之间至少有2个o                                           |
| fo{2,5}f | f和f之间至少有2个o,最多有5个o                                |
| ?        | 非贪婪                                                       |
| fo?f     | f和f之间可以有一个0或者没有0单不可以有其他; 例如: ab+?" 匹配的结果就是 ab 不在是无限的abbbbb* |




## js用法

> ​	**search():获取位置 ** **replace():替换** **test()返回布尔值**

## 支持正则表达式的 String 对象的方法

| 方法      | 描述                             | FF                  |
| :-------- | :------------------------------- | :------------------ |
| [search]  | 检索与正则表达式相匹配的值。     | 仅支持 i 匹配第一个 |
| [match]   | 找到一个或多个正则表达式的匹配。 | 1                   |
| [replace] | 替换与正则表达式匹配的子串。     | 1                   |
| [split]   | 把字符串分割为字符串数组。       |                     |

#### search()

~~~js
//使用方法1: 使用正则表达式
var str = "Visit w3cschool";
var n = str.search(/w3cschool/i);
console.log(n) // 6 所处的位置

// 使用方法2: 字符串作为参数。字符串参数会转换为正则表达式
var str = "Visit w3cschool!";
var n = str.search("w3cschool");
console.log(n) // 6 所处的位置

~~~

#### replace()

~~~js
// 使用方法1: 使用正则表达式,替换指定内容
var str = "Visit Microsoft!";
var res = str.replace(/microsoft/i, "w3cschool");
console.log(res) // Visit w3cschool!
// 使用方法2: 接收字符串作为参数
var str = "Visit Microsoft!";
var res = str.replace("Microsoft", "w3cschool");
console.log(res) // Visit w3cschool!
~~~

## 正则对象的方法

## test() 是否包含

~~~js
//方法1 : 定义一个正则对象,调用test将验证字符串放入
var patt = /e/;
patt.test("The best things in life are free!");
只要字符串包含正则规则,返回真,否则返回假
true
//方法2 : 直接使用正则表达式调用test方法
/e/.test("The best things in life are free!")
~~~





## RegExp 对象方法

| 方法    | 描述                                               | FF   | IE   |
| :------ | :------------------------------------------------- | :--- | :--- |
| compile | 编译正则表达式。                                   | 1    | 4    |
| exec    | 检索字符串中指定的值。返回找到的值，并确定其位置。 | 1    | 4    |
| test    | 检索字符串中指定的值。返回 true 或 false。         | 1    | 4    |

# 实例解释

~~~markdown
 /\.(png||jpe?g||gif)$/
前后两个//表示规则
\表示任意长度任意字符
.表示字符 .
()表示里面的内容都在适配
|| 表示既可以是png,也可以是gif,也可以是jpeg
& 表示行尾
e? 表示字符e有可以,没有也可以


~~~



解析事例两则

~~~js
#匹配 IP 地址的正则表达式：

"((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)"
我们分段来看。
先看第一段 "(2[0-4]\d|25[0-5]|[01]?\d\d?)\.)"，这里用 "|" 分割了三种匹配情况。
第一种是 "2[0-4]\d"，即三位数字，第一位是 2，第二位是 0 - 4 之间，第三位是任意数字。
第二种是 "25[0-5]"，三位数字，第一位是 2，第二位是 5，第三位是 0 - 5 之间。
第三种是 "[01]?\d\d?"，第一位是 0 或者 1，匹配零次或一次，第二位和第三位是任意数字，第三位数字匹配零次或一次，也就是 一位数，两位数，三位数都可能满足这种情况。
第一段末尾是 "\." 作为分隔符。
再来看第二段 "{3}"，这个表示前面的子表达式重复三次，也就是 IP 地址的前三个字节。
再看第三段 "(2[0-4]\d|25[0-5]|[01]?\d\d?)"，和第一段是一样的。


#匹配电子邮箱：
"([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})"
也是分段来看。
第一段 "([a-z0-9_\.-]+)"，表示匹配 a-z 范围内的字母，0-9 范围的数字，以及 "_"，"."，"-" 三个字符，"+" 表示至少有一个字符。
第二段 "@" 表示匹配 "@" 字符。
第三段 "([\da-z\.-]+)"，"\d" 表示匹配任意数字，a-z 范围的字母，"."，"-" 两个字符，"+" 至少有一个字符。
第四段 "\." 表示匹配 "." 字符。
第五段 "([a-z\.]{2,6})"，表示匹配 a-z 范围的字母，"." 字符，"{2,6}" 表示至少 2 个字符，至多 6 个字符。
经过上面的讲解，大家应该对正则表达式有了进一步的了解。

~~~

